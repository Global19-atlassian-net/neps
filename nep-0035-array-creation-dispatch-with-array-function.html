
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NEP 35 — Array Creation Dispatching With __array_function__ &#8212; NumPy Enhancement Proposals</title>
    
  <link rel="stylesheet" href="_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    
  <link rel="preload" as="script" href="_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="NEP 36 — Fair play" href="nep-0036-fair-play.html" />
    <link rel="prev" title="NEP 31 — Context-local and global overrides of the NumPy API" href="nep-0031-uarray.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
<link rel="stylesheet" href="_static/numpy.css" type="text/css" />

    <!-- PR #17220: This is added via javascript in versionwarning.js  -->
    <!-- link rel="canonical" href="http://numpy.org/doc/stable/nep-0035-array-creation-dispatch-with-array-function.html" / -->


  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    <a class="navbar-brand" href="content.html">
    
      <img src="_static/numpylogo.svg" class="logo" alt="logo" />
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item active">
            <a class="nav-link" href="index.html">Index</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="scope.html">The Scope of NumPy</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="roadmap.html">Current roadmap</a>
        </li>
        
        
        <li class="nav-item">
            <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">Wishlist<i class="fas fa-external-link-alt"></i></a>
        </li>
        
      </ul>


      

      <ul class="navbar-nav">
        
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/numpy/numpy" target="_blank" rel="noopener">
              <span><i class="fab fa-github-square"></i></span>
            </a>
          </li>
        
        
          <li class="nav-item">
            <a class="nav-link" href="https://twitter.com/numpy_team" target="_blank" rel="noopener">
              <span><i class="fab fa-twitter-square"></i></span>
            </a>
          </li>
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
          
        
        
        
        
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#abstract" class="nav-link">Abstract</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#motivation-and-scope" class="nav-link">Motivation and Scope</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#usage-and-impact" class="nav-link">Usage and Impact</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#backward-compatibility" class="nav-link">Backward Compatibility</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#detailed-description" class="nav-link">Detailed description</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#related-work" class="nav-link">Related work</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#implementation" class="nav-link">Implementation</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#function-dispatching" class="nav-link">Function Dispatching</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#reading-the-reference-array-downstream" class="nav-link">Reading the Reference Array Downstream</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#alternatives" class="nav-link">Alternatives</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#discussion" class="nav-link">Discussion</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#references" class="nav-link">References</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#copyright" class="nav-link">Copyright</a>
        </li>
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="nep-35-array-creation-dispatching-with-array-function">
<span id="nep35"></span><h1>NEP 35 — Array Creation Dispatching With __array_function__<a class="headerlink" href="#nep-35-array-creation-dispatching-with-array-function" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Peter Andreas Entschev &lt;<a class="reference external" href="mailto:pentschev&#37;&#52;&#48;nvidia&#46;com">pentschev<span>&#64;</span>nvidia<span>&#46;</span>com</a>&gt;</p>
</dd>
<dt class="field-even">Status</dt>
<dd class="field-even"><p>Draft</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>Standards Track</p>
</dd>
<dt class="field-even">Created</dt>
<dd class="field-even"><p>2019-10-15</p>
</dd>
<dt class="field-odd">Updated</dt>
<dd class="field-odd"><p>2020-11-06</p>
</dd>
<dt class="field-even">Resolution</dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>We propose the introduction of a new keyword argument <code class="docutils literal notranslate"><span class="pre">like=</span></code> to all array
creation functions to address one of the shortcomings of <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>,
as described by NEP 18 <a class="footnote-reference brackets" href="#id9" id="id1">1</a>. The <code class="docutils literal notranslate"><span class="pre">like=</span></code> keyword argument will create an
instance of the argument’s type, enabling direct creation of non-NumPy arrays.
The target array type must implement the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol.</p>
</div>
<div class="section" id="motivation-and-scope">
<h2>Motivation and Scope<a class="headerlink" href="#motivation-and-scope" title="Permalink to this headline">¶</a></h2>
<p>Many libraries implement the NumPy API, such as Dask for graph
computing, CuPy for GPGPU computing, xarray for N-D labeled arrays, etc. Underneath,
they have adopted the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol which allows NumPy to understand
and treat downstream objects as if they are the native <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> object.
Hence the community while using various libraries still benefits from a unified
NumPy API. This not only brings great convenience for standardization but also
removes the burden of learning a new API and rewriting code for every new
object. In more technical terms, this mechanism of the protocol is called a
“dispatcher”, which is the terminology we use from here onwards when referring
to that.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>    <span class="c1"># Creates dask.array</span>
<span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                  <span class="c1"># Returns dask.array</span>
</pre></div>
</div>
<p>Note above how we called Dask’s implementation of <code class="docutils literal notranslate"><span class="pre">diff</span></code> via the NumPy
namespace by calling <code class="docutils literal notranslate"><span class="pre">np.diff</span></code>, and the same would apply if we had a CuPy
array or any other array from a library that adopts <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>.
This allows writing code that is agnostic to the implementation library, thus
users can write their code once and still be able to use different array
implementations according to their needs.</p>
<p>Obviously, having a protocol in-place is useful if the arrays are created
elsewhere and let NumPy handle them. But still these arrays have to be started
in their native library and brought back. Instead if it was possible to create
these objects through NumPy API then there would be an almost complete
experience, all using NumPy syntax. For example, say we have some CuPy array
<code class="docutils literal notranslate"><span class="pre">cp_arr</span></code>, and want a similar CuPy array with identity matrix. We could still
write the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Instead, the better way would be using to only use the NumPy API, this could now
be achieved with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">like</span><span class="o">=</span><span class="n">cp_arr</span><span class="p">)</span>
</pre></div>
</div>
<p>As if by magic, <code class="docutils literal notranslate"><span class="pre">x</span></code> will also be a CuPy array, as NumPy was capable to infer
that from the type of <code class="docutils literal notranslate"><span class="pre">cp_arr</span></code>. Note that this last step would not be possible
without <code class="docutils literal notranslate"><span class="pre">like=</span></code>, as it would be impossible for the NumPy to know the user
expects a CuPy array based only on the integer input.</p>
<p>The new <code class="docutils literal notranslate"><span class="pre">like=</span></code> keyword proposed is solely intended to identify the downstream
library where to dispatch and the object is used only as reference, meaning that
no modifications, copies or processing will be performed on that object.</p>
<p>We expect that this functionality will be mostly useful to library developers,
allowing them to create new arrays for internal usage based on arrays passed
by the user, preventing unnecessary creation of NumPy arrays that will
ultimately lead to an additional conversion into a downstream array type.</p>
<p>Support for Python 2.7 has been dropped since NumPy 1.17, therefore we make use
of the keyword-only argument standard described in PEP-3102 <a class="footnote-reference brackets" href="#id10" id="id2">2</a> to implement
<code class="docutils literal notranslate"><span class="pre">like=</span></code>, thus preventing it from being passed by position.</p>
</div>
<div class="section" id="usage-and-impact">
<span id="neps-like-kwarg-usage-and-impact"></span><h2>Usage and Impact<a class="headerlink" href="#usage-and-impact" title="Permalink to this headline">¶</a></h2>
<p>NumPy users who don’t use other arrays from downstream libraries can continue
to use array creation routines without a <code class="docutils literal notranslate"><span class="pre">like=</span></code> argument. Using
<code class="docutils literal notranslate"><span class="pre">like=np.ndarray</span></code> will work as if no array was passed via that argument.
However, this will incur additional checks that will negatively impact
performance.</p>
<p>To understand the intended use for <code class="docutils literal notranslate"><span class="pre">like=</span></code>, and before we move to more complex
cases, consider the following illustrative example consisting only of NumPy and
CuPy arrays:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cupy</span>

<span class="k">def</span> <span class="nf">my_pad</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">padding</span><span class="p">):</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">like</span><span class="o">=</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">padding</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">padding</span><span class="p">))</span>

<span class="n">my_pad</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>    <span class="c1"># Returns np.ndarray</span>
<span class="n">my_pad</span><span class="p">(</span><span class="n">cupy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Returns cupy.core.core.ndarray</span>
</pre></div>
</div>
<p>Note in the <code class="docutils literal notranslate"><span class="pre">my_pad</span></code> function above how <code class="docutils literal notranslate"><span class="pre">arr</span></code> is used as a reference to
dictate what array type padding should have, before concatenating the arrays to
produce the result. On the other hand, if <code class="docutils literal notranslate"><span class="pre">like=</span></code> wasn’t used, the NumPy case
would still work, but CuPy wouldn’t allow this kind of automatic
conversion, ultimately raising a
<code class="docutils literal notranslate"><span class="pre">TypeError:</span> <span class="pre">Only</span> <span class="pre">cupy</span> <span class="pre">arrays</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">concatenated</span></code> exception.</p>
<p>Now we should look at how a library like Dask could benefit from <code class="docutils literal notranslate"><span class="pre">like=</span></code>.
Before we understand that, it’s important to understand a bit about Dask basics
and how it ensures correctness with <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>. Note that Dask can
perform computations on different sorts of objects, like dataframes, bags and
arrays, here we will focus strictly on arrays, which are the objects we can use
<code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> with.</p>
<p>Dask uses a graph computing model, meaning it breaks down a large problem in
many smaller problems and merges their results to reach the final result. To
break the problem down into smaller ones, Dask also breaks arrays into smaller
arrays that it calls “chunks”. A Dask array can thus consist of one or more
chunks and they may be of different types. However, in the context of
<code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>, Dask only allows chunks of the same type; for example,
a Dask array can be formed of several NumPy arrays or several CuPy arrays, but
not a mix of both.</p>
<p>To avoid mismatched types during computation, Dask keeps an attribute <code class="docutils literal notranslate"><span class="pre">_meta</span></code> as
part of its array throughout computation: this attribute is used to both predict
the output type at graph creation time, and to create any intermediary arrays
that are necessary within some function’s computation. Going back to our
previous example, we can use <code class="docutils literal notranslate"><span class="pre">_meta</span></code> information to identify what kind of
array we would use for padding, as seen below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cupy</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">from</span> <span class="nn">dask.array.utils</span> <span class="kn">import</span> <span class="n">meta_from_array</span>

<span class="k">def</span> <span class="nf">my_dask_pad</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">padding</span><span class="p">):</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">like</span><span class="o">=</span><span class="n">meta_from_array</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">padding</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">padding</span><span class="p">))</span>

<span class="c1"># Returns dask.array&lt;concatenate, shape=(9,), dtype=int64, chunksize=(5,), chunktype=numpy.ndarray&gt;</span>
<span class="n">my_dask_pad</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Returns dask.array&lt;concatenate, shape=(9,), dtype=int64, chunksize=(5,), chunktype=cupy.ndarray&gt;</span>
<span class="n">my_dask_pad</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">cupy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Note how <code class="docutils literal notranslate"><span class="pre">chunktype</span></code> in the return value above changes from
<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> in the first <code class="docutils literal notranslate"><span class="pre">my_dask_pad</span></code> call to <code class="docutils literal notranslate"><span class="pre">cupy.ndarray</span></code> in the
second. We have also renamed the function to <code class="docutils literal notranslate"><span class="pre">my_dask_pad</span></code> in this example
with the intent to make it clear that this is how Dask would implement such
functionality, should it need to do so, as it requires Dask’s internal tools
that are not of much use elsewhere.</p>
<p>To enable proper identification of the array type we use Dask’s utility function
<code class="docutils literal notranslate"><span class="pre">meta_from_array</span></code>, which was introduced as part of the work to support
<code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>, allowing Dask to handle <code class="docutils literal notranslate"><span class="pre">_meta</span></code> appropriately. Readers
can think of <code class="docutils literal notranslate"><span class="pre">meta_from_array</span></code> as a special function that just returns the
type of the underlying Dask array, for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np_arr</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">cp_arr</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">cupy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

<span class="n">meta_from_array</span><span class="p">(</span><span class="n">np_arr</span><span class="p">)</span>  <span class="c1"># Returns a numpy.ndarray</span>
<span class="n">meta_from_array</span><span class="p">(</span><span class="n">cp_arr</span><span class="p">)</span>  <span class="c1"># Returns a cupy.ndarray</span>
</pre></div>
</div>
<p>Since the value returned by <code class="docutils literal notranslate"><span class="pre">meta_from_array</span></code> is a NumPy-like array, we can
just pass that directly into the <code class="docutils literal notranslate"><span class="pre">like=</span></code> argument.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">meta_from_array</span></code> function is primarily targeted at the library’s internal
usage to ensure chunks are created with correct types. Without the <code class="docutils literal notranslate"><span class="pre">like=</span></code>
argument, it would be impossible to ensure <code class="docutils literal notranslate"><span class="pre">my_pad</span></code> creates a padding array
with a type matching that of the input array, which would cause a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>
exception to be raised by CuPy, as discussed above would happen to the CuPy case
alone. Combining Dask’s internal handling of meta arrays and the proposed
<code class="docutils literal notranslate"><span class="pre">like=</span></code> argument, it now becomes possible to handle cases involving creation
of non-NumPy arrays, which is likely the heaviest limitation Dask currently
faces from the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol.</p>
</div>
<div class="section" id="backward-compatibility">
<h2>Backward Compatibility<a class="headerlink" href="#backward-compatibility" title="Permalink to this headline">¶</a></h2>
<p>This proposal does not raise any backward compatibility issues within NumPy,
given that it only introduces a new keyword argument to existing array creation
functions with a default <code class="docutils literal notranslate"><span class="pre">None</span></code> value, thus not changing current behavior.</p>
</div>
<div class="section" id="detailed-description">
<h2>Detailed description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<p>The introduction of the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol allowed downstream
library developers to use NumPy as a dispatching API. However, the protocol
did not – and did not intend to – address the creation of arrays by downstream
libraries, preventing those libraries from using such important functionality in
that context.</p>
<p>The purpose of this NEP is to address that shortcoming in a simple and
straighforward way: introduce a new <code class="docutils literal notranslate"><span class="pre">like=</span></code> keyword argument, similar to how
the <code class="docutils literal notranslate"><span class="pre">empty_like</span></code> family of functions work. When array creation functions
receive such an argument, they will trigger the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol,
and call the downstream library’s own array creation function implementation.
The <code class="docutils literal notranslate"><span class="pre">like=</span></code> argument, as its own name suggests, shall be used solely for the
purpose of identifying where to dispatch.  In contrast to the way
<code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> has been used so far (the first argument identifies the
target downstream library), and to avoid breaking NumPy’s API with regards to
array creation, the new <code class="docutils literal notranslate"><span class="pre">like=</span></code> keyword shall be used for the purpose of
dispatching.</p>
<p>Downstream libraries will benefit from the <code class="docutils literal notranslate"><span class="pre">like=</span></code> argument without any
changes to their API, given the argument only needs to be implemented by NumPy.
It’s still allowed that downstream libraries include the <code class="docutils literal notranslate"><span class="pre">like=</span></code> argument,
as it can be useful in some cases, please refer to
<a class="reference internal" href="#neps-like-kwarg-implementation"><span class="std std-ref">Implementation</span></a> for details on those cases. It will still
be required that downstream libraries implement the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>
protocol, as described by NEP 18 <a class="footnote-reference brackets" href="#id9" id="id3">1</a>, and appropriately introduce the argument
to their calls to NumPy array creation functions, as exemplified in
<a class="reference internal" href="#neps-like-kwarg-usage-and-impact"><span class="std std-ref">Usage and Impact</span></a>.</p>
</div>
<div class="section" id="related-work">
<h2>Related work<a class="headerlink" href="#related-work" title="Permalink to this headline">¶</a></h2>
<p>Other NEPs have been written to address parts of <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>
protocol’s limitation, such as the introduction of the <code class="docutils literal notranslate"><span class="pre">__duckarray__</span></code>
protocol in NEP 30 <a class="footnote-reference brackets" href="#id11" id="id4">3</a>, and the introduction of an overriding mechanism called
<code class="docutils literal notranslate"><span class="pre">uarray</span></code> by NEP 31 <a class="footnote-reference brackets" href="#id12" id="id5">4</a>.</p>
</div>
<div class="section" id="implementation">
<span id="neps-like-kwarg-implementation"></span><h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>The implementation requires introducing a new <code class="docutils literal notranslate"><span class="pre">like=</span></code> keyword to all existing
array creation functions of NumPy. As examples of functions that would add this
new argument (but not limited to) we can cite those taking array-like objects
such as <code class="docutils literal notranslate"><span class="pre">array</span></code> and <code class="docutils literal notranslate"><span class="pre">asarray</span></code>, functions that create arrays based on
numerical inputs such as <code class="docutils literal notranslate"><span class="pre">range</span></code> and <code class="docutils literal notranslate"><span class="pre">identity</span></code>, as well as the <code class="docutils literal notranslate"><span class="pre">empty</span></code>
family of functions, even though that may be redundant, since specializations
for those already exist with the naming format <code class="docutils literal notranslate"><span class="pre">empty_like</span></code>. As of the
writing of this NEP, a complete list of array creation functions can be
found in <a class="footnote-reference brackets" href="#id13" id="id6">5</a>.</p>
<p>This newly proposed keyword shall be removed by the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>
mechanism from the keyword dictionary before dispatching. The purpose for this
is twofold:</p>
<ol class="arabic simple">
<li><p>Simplifies adoption of array creation by those libraries already opting-in
to implement the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol, thus removing the
requirement to explicitly opt-in for all array creation functions; and</p></li>
<li><p>Most downstream libraries will have no use for the keyword argument, and
those that do may accomplish so by capturing <code class="docutils literal notranslate"><span class="pre">self</span></code> from
<code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>.</p></li>
</ol>
<p>Downstream libraries thus do not require to include the <code class="docutils literal notranslate"><span class="pre">like=</span></code> keyword to
their array creation APIs. In some cases (e.g., Dask), having the <code class="docutils literal notranslate"><span class="pre">like=</span></code>
keyword can be useful, as it would allow the implementation to identify
array internals. As an example, Dask could benefit from the reference array
to identify its chunk type (e.g., NumPy, CuPy, Sparse), and thus create a new
Dask array backed by the same chunk type, something that’s not possible unless
Dask can read the reference array’s attributes.</p>
<div class="section" id="function-dispatching">
<h3>Function Dispatching<a class="headerlink" href="#function-dispatching" title="Permalink to this headline">¶</a></h3>
<p>There are two different cases to dispatch: Python functions, and C functions.
To permit <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> dispatching, one possible implementation is to
decorate Python functions with <code class="docutils literal notranslate"><span class="pre">overrides.array_function_dispatch</span></code>, but C
functions have a different requirement, which we shall describe shortly.</p>
<p>The example below shows a suggestion on how the <code class="docutils literal notranslate"><span class="pre">asarray</span></code> could be decorated
with <code class="docutils literal notranslate"><span class="pre">overrides.array_function_dispatch</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_asarray_decorator</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">like</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">like</span><span class="p">,)</span>

<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_asarray_decorator</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">like</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
</pre></div>
</div>
<p>Note in the example above that the implementation remains unchanged, the only
difference is the decoration, which uses the new <code class="docutils literal notranslate"><span class="pre">_asarray_decorator</span></code> function
to instruct the <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> protocol to dispatch if <code class="docutils literal notranslate"><span class="pre">like</span></code> is not
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>We will now look at a C function example, and since <code class="docutils literal notranslate"><span class="pre">asarray</span></code> is anyway a
specialization of <code class="docutils literal notranslate"><span class="pre">array</span></code>, we will use the latter as an example now. As
<code class="docutils literal notranslate"><span class="pre">array</span></code> is a C function, currently all NumPy does regarding its Python source
is to import the function and adjust its <code class="docutils literal notranslate"><span class="pre">__module__</span></code> to <code class="docutils literal notranslate"><span class="pre">numpy</span></code>. The
function will now be decorated with a specialization of
<code class="docutils literal notranslate"><span class="pre">overrides.array_function_from_dispatcher</span></code>, which shall take care of adjusting
the module too.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array_function_nodocs_from_c_func_and_dispatcher</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
    <span class="n">overrides</span><span class="o">.</span><span class="n">array_function_from_dispatcher</span><span class="p">,</span>
    <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">docs_from_dispatcher</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nd">@array_function_nodocs_from_c_func_and_dispatcher</span><span class="p">(</span><span class="n">_multiarray_umath</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
          <span class="n">like</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">like</span><span class="p">,)</span>
</pre></div>
</div>
<p>There are two downsides to the implementation above for C functions:</p>
<ol class="arabic simple">
<li><p>It creates another Python function call; and</p></li>
<li><p>To follow current implementation standards, documentation should be attached
directly to the Python source code.</p></li>
</ol>
<p>The first version of this proposal suggested the implementation above as one
viable solution for NumPy functions implemented in C. However, due to the
downsides pointed out above we have decided to discard any changes on the Python
side and resolve those issues with a pure-C implementation. Please refer to
<a class="footnote-reference brackets" href="#id15" id="id7">7</a> for details.</p>
</div>
<div class="section" id="reading-the-reference-array-downstream">
<h3>Reading the Reference Array Downstream<a class="headerlink" href="#reading-the-reference-array-downstream" title="Permalink to this headline">¶</a></h3>
<p>As stated in the beginning of <a class="reference internal" href="#neps-like-kwarg-implementation"><span class="std std-ref">Implementation</span></a> section,
<code class="docutils literal notranslate"><span class="pre">like=</span></code> is not propagated to the downstream library, nevertheless, it’s still
possible to access it. This requires some changes in the downstream library’s
<code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> definition, where the <code class="docutils literal notranslate"><span class="pre">self</span></code> attribute is in practice
that passed via <code class="docutils literal notranslate"><span class="pre">like=</span></code>. This is the case because we use <code class="docutils literal notranslate"><span class="pre">like=</span></code> as the
dispatching array, unlike other compute functions covered by NEP-18 that usually
dispatch on the first positional argument.</p>
<p>An example of such use is to create a new Dask array while preserving its
backend type:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Returns dask.array&lt;array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=cupy.ndarray&gt;</span>
<span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">like</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(())))</span>

<span class="c1"># Returns a cupy.ndarray</span>
<span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">like</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(())))</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
</pre></div>
</div>
<p>Note how above the array is backed by <code class="docutils literal notranslate"><span class="pre">chunktype=cupy.ndarray</span></code>, and the
resulting array after computing it is also a <code class="docutils literal notranslate"><span class="pre">cupy.ndarray</span></code>. If Dask did
not use the <code class="docutils literal notranslate"><span class="pre">like=</span></code> argument via the <code class="docutils literal notranslate"><span class="pre">self</span></code> attribute from
<code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>, the example above would be backed by <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>
instead:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Returns dask.array&lt;array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=numpy.ndarray&gt;</span>
<span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">like</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(())))</span>

<span class="c1"># Returns a numpy.ndarray</span>
<span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">like</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(())))</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
</pre></div>
</div>
<p>Given the library would need to rely on <code class="docutils literal notranslate"><span class="pre">self</span></code> attribute from
<code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> to dispatch the function with the correct reference
array, we suggest one of two alternatives:</p>
<ol class="arabic simple">
<li><p>Introduce a list of functions in the downstream library that do support the
<code class="docutils literal notranslate"><span class="pre">like=</span></code> argument and pass <code class="docutils literal notranslate"><span class="pre">like=self</span></code> when calling the function; or</p></li>
<li><p>Inspect whether the function’s signature and verify whether it includes the
<code class="docutils literal notranslate"><span class="pre">like=</span></code> argument. Note that this may incur in a higher performance penalty
and assumes introspection is possible, which may not be if the function is
a C function.</p></li>
</ol>
<p>To make things clearer, let’s take a look at how suggestion 2 could be
implemented in Dask. The current relevant part of <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code>
definition in Dask is seen below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__array_function__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Code not relevant for this example here</span>

    <span class="c1"># Dispatch ``da_func`` (da.asarray, for example) with *args and **kwargs</span>
    <span class="n">da_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>And this is how the updated code would look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__array_function__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Code not relevant for this example here</span>

    <span class="c1"># Inspect ``da_func``&#39;s  signature and store keyword-only arguments</span>
    <span class="kn">import</span> <span class="nn">inspect</span>
    <span class="n">kwonlyargs</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">da_func</span><span class="p">)</span><span class="o">.</span><span class="n">kwonlyargs</span>

    <span class="c1"># If ``like`` is contained in ``da_func``&#39;s signature, add ``like=self``</span>
    <span class="c1"># to the kwargs dictionary.</span>
    <span class="k">if</span> <span class="s1">&#39;like&#39;</span> <span class="ow">in</span> <span class="n">kwonlyargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;like&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="c1"># Dispatch ``da_func`` (da.asarray, for example) with args and kwargs.</span>
    <span class="c1"># Here, kwargs contain ``like=self`` if the function&#39;s signature does too.</span>
    <span class="n">da_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="alternatives">
<h2>Alternatives<a class="headerlink" href="#alternatives" title="Permalink to this headline">¶</a></h2>
<p>Recently a new protocol to replace <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> entirely was proposed
by NEP 37 <a class="footnote-reference brackets" href="#id14" id="id8">6</a>, which would require considerable rework by downstream libraries
that adopt <code class="docutils literal notranslate"><span class="pre">__array_function__</span></code> already, because of that we still believe the
<code class="docutils literal notranslate"><span class="pre">like=</span></code> argument is beneficial for NumPy and downstream libraries. However,
that proposal wouldn’t necessarily be considered a direct alternative to the
present NEP, as it would replace NEP 18 entirely, upon which this builds.
Discussion on details about this new proposal and why that would require rework
by downstream libraries is beyond the scope of the present proposal.</p>
</div>
<div class="section" id="discussion">
<h2>Discussion<a class="headerlink" href="#discussion" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://mail.python.org/pipermail/numpy-discussion/2020-August/080919.html">Further discussion on implementation and the NEP’s content</a></p></li>
</ul>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://numpy.org/neps/nep-0018-array-function-protocol.html">NEP 18 - A dispatch mechanism for NumPy’s high level array functions</a>.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p><a class="reference external" href="https://www.python.org/dev/peps/pep-3102/">PEP 3102 — Keyword-Only Arguments</a>.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p><a class="reference external" href="https://numpy.org/neps/nep-0030-duck-array-protocol.html">NEP 30 — Duck Typing for NumPy Arrays - Implementation</a>.</p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/numpy/numpy/pull/14389">NEP 31 — Context-local and global overrides of the NumPy API</a>.</p>
</dd>
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id6">5</a></span></dt>
<dd><p><a class="reference external" href="https://docs.scipy.org/doc/numpy-1.17.0/reference/routines.array-creation.html">Array creation routines</a>.</p>
</dd>
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id8">6</a></span></dt>
<dd><p><a class="reference external" href="https://numpy.org/neps/nep-0037-array-module.html">NEP 37 — A dispatch protocol for NumPy-like modules</a>.</p>
</dd>
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id7">7</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/numpy/numpy/pull/16935">Implementation’s pull request on GitHub</a></p>
</dd>
</dl>
</div>
<div class="section" id="copyright">
<h2>Copyright<a class="headerlink" href="#copyright" title="Permalink to this headline">¶</a></h2>
<p>This document has been placed in the public domain.</p>
</div>
</div>


              </div>
              
              
          </main>
          

      </div>
    </div>

    
  <script src="_static/js/index.d3f166471bb80abb5163.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2017-2018, NumPy Developers.<br/>
        Last updated on Feb 22, 2021.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>